---
title: "QPSK Modulation/Demodulation with GNU Radio"
date: 2025-09-01
tags: dsp notes study communication rf
---

<h3>Building Blocks</h3>

<h4>Random Source</h4>

This block generates a random stream of samples with levels between **Minimum** and **Maximum**. The total number of samples generated is given by **Num of Samples**.

Here, the output type is ==byte==, which can represent an integer between 0 and 255. So we can potentially use this flow graph to simulate modulation order of up to 256-QAM.

<h4>Constellation Modulator</h4>
This block takes each byte generated by the random source and maps it to a QAM constellation point. The output is a stream of complex number.

Here are the key arguments for this block:

- Constellation
    - Specifies the Constellation object used to map the input bytes to complex numbers.
- Samples/Symbol
    - Dictates the symbol rate of our transmitted signal. 
    - Symbol Rate = Samples per Symbol \\(\times\\) Sample Rate
- Excess Bandwidth
    - Determines the (root-raised cosine) pulse shaping filter, which suppresses out-of-band energy.
- Differential Encoding
    - Specifies whether or not [differential encoding](https://en.wikipedia.org/wiki/Differential_coding) is used.

<h4>Constellation Rect. Object</h4>

A ==rectangular== constellation object. This block serves as a map which translates the random integers generated by the Random Source block to a complex numbers corresponding to a grid on the I/Q plane (a constellation).

<h4>Throttle</h4>

Since we are running a simulation with no actual hardware, we need to add this block to prevent the flowgraph from consuming too much processing power. In fact, the flowgraph will try to run as fast as out CPU can handle. 

When there are rate-limiting hardware attached, such as a software-defined radio, this block is not needed.

The purpose of this block is explained very well by a Reddit post [here](https://www.reddit.com/r/GNURadio/comments/1d4pz1u/sample_rates_why_cant_i_slow_down_gnuradio/).

<details>
<summary>Explanation for the Throttle Block</summary>
TLDR: if you don't have a radio to enforce a real-world speed, then you want a Throttle block somewhere in your graph.

The thing to remember about GNURadio is that it is not designed to limit its processing to real-time. It runs as fast as the processor can execute the code in the various blocks. Execution is opportunistic: if a block has sufficient data in its input buffers and sufficient space to write into its output buffers, it will be scheduled and will execute as soon as the CPU has time to run it.
At any given time, a flowgraph has a buffer that is currently limiting the speed of the overall system. Examples:

- The output buffer of a source block that is waiting for data from the world outside GNURadio (like those coming in from a physical radio receiver)
- The input buffer of a sink block that is waiting to send data to the outside world (like the input to a physical radio transmitter)
- The input buffer to a complex processing block, which slows down upstream blocks (who have to wait for somewhere to put their outputs) and slows down downstream blocks (who have no input to process yet)

(Keep in mind that the output buffer of one block is the same buffer as the input buffer to the next block in the graph.)

In most cases where there is a physical radio involved, assuming you're not getting overruns or underruns reported by the radio, then the sample rate of that radio limits the flowgraph's execution speed.

GNURadio Companion creates a bit of confusion by supplying a "sample_rate" variable for every new graph, but that's just a number being assigned to a variable named "sample_rate". A graph does not inherently have a sample rate; instead, that's just the variable name used by default for most physical hardware blocks. If your graph has no hardware clock limiting its execution speed, then "sample_rate" is not used to set the processing rate.

Long story short - if you don't have a hardware clock limiting the rate of your flowgraph but you still want to "emulate" a fixed sample rate, then you want a Throttle block. The Throttle block's job is to use the system clock to determine when to copy output from its input buffer to its output buffer. By doing so, it limits the speed of the whole flowgraph. However, you almost never want a Throttle block in a flowgraph that has a real radio, so be sure to remove or bypass it when you get the real radio going. 
</details>


<h4>Channel Model</h4>

<h4>Polyphase Clock Sync</h4>

<h4>Linear Equalizer</h4>

<h4>Costas Loop</h4>

<h4>Constellation Sink</h4>